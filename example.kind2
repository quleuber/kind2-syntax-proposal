type Empty { }
type Unit  { Un }

// ADT
type Bool {
  False
  True
}

type Nat {
  Zero
  (Succ (pred: Nat))
}

struct Pair <A: Type> <B: Type> {
  fst: A
  snd: B
}

Color : Type
  Red   : Color
  Green : Color
  Blue  : Color

Not (T: Type) : Type = @T -> Empty

// Negates a boolean
neg (x: Bool) : Bool {
  neg False = True
  neg True  = False
}

// Alternative
neg (x: Bool) : Bool = (iff x False True)

iff <T: Type> (condition: Bool) (when_true: T) (when_false: T) : T {
  iff False _ x = x
  iff True x _ = x
}

// Function returning lambda
add_this (n: Nat) : @Nat -> Nat =
  @x => (add x 2)

double (n: Nat) : Nat {
  double Zero        = Zero
  double (Succ pred) = (Succ (Succ pred))
}

half (n: Nat) : Nat {
  half (Succ (Succ pred)) =
    let tail = (half pred)
    (Succ tail)
  half _                  = Zero
}

cong (T: Type) (U: Type) (a: T) (b: T) (f: @(x: T) -> U) (e: (a = b)) : f a = f b {
  cong _ _ a b f e =
    rewrite x with e on (f x = f b) in
    refl (f b)
}

BFT (n: Nat) : Nat {
  BFT Zero        = (refl Zero)
  BFT (Succ pred) =
    let e0 = (BFT pred)
    let e1 = (cong _ _ _ _ (@x => Succ x) e0)
    e1
}

// True isn't False
true_is_not_false : Not (True = False) =
  @e =>
    rewrite x with e on (if x Empty Unit) in Un

// Higher-level stuff

record Mappable (T: Type) {
  map : <a: Type> <b: Type> (f: a -> b) (xs: T a) : (T b)
}

List.Mappable: Mappable<List> = {
  let {
    map {a: Type} {b: Type} (f: a -> b) (xs: List a) : (List b) {
      map _  List.Nil        = Nil
      map f (List.Cons x xs) = (List.Cons (f x) (map f xs))
    }
  } in
  (Mappable map)

map
  <C: @Type -> Type> <MC: Mappable C>
  <A: Type> <B: Type>
  (f: @A -> B) (xs: C A) : C B =
    (MC.map f xs)

record Add <T: Type> {
  add  a b : T
  comm a b : (add a b = add b a)
}

Nat.Add : Add Nat = 
  let {
    fn add (a: Nat) (b: Nat) : Nat
      add Zero        b = b
      add (Succ pred) b = add pred (Succ b)
    }

    fn comm (a: T) (b: T) : (add a b) = (add b a) {
      comm Zero b =
        (mirror (add b 0) b Nat.add.zero_right)
      comma a b =
        [...]
    }
  } in
    (Add <Nat> add comm)

map_double <C: @Type -> Type> <_: Mappable C> (N: Type) <N.Add: Add N> (xs: C N) : C N =
  (map <C> (@x => (N.Add.add x x)) xs)
